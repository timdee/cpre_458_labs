%% The comment character in TeX / LaTeX is the percent character.
%% The following chunk is called the header

\documentclass{article} % essential first line
\usepackage{times}    % this uses fonts which will look nice in PDF format
\usepackage{graphicx}   % needed for the figures
\usepackage{url}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

%% Set the folder where pictures are located
\graphicspath{ {figures/} }

%% Here I adjust the margins

\oddsidemargin -0.25in    % Left margin is 1in + this value
\textwidth 6.75in   % Right margin is not set explicitly
\topmargin 0in      % Top margin is 1in + this value
\textheight 9in     % Bottom margin is not set explicitly
\columnsep 0.25in   % separation between columns

%% set the line spacing
\linespread{1}

%% Define a macro for inserting postscript images
%% ==============================================
%% This is a macro which nominally takes 3 parameters, 
%% it would be used as follows to insert and encapsulated postscript
%% image at the location where it is used.
%%
%% \EPSFIG{epsfilename}{caption}{label}
%% - epsfilename is the name of the encapsulated postscript file to be
%%               inserted at this location
%% - caption is the text to be shown as the figure caption, it will be
%%           prepended by Figure X.  The number X can be referenced
%%           using the label parameter.
%% - label is a name given to the figure, it can be referenced using the
%%         \ref{label} command.

%\def\EPSFIG[#1]#2#3#4{   % Don't be scared by this monsrosity
%\begin{figure}[hbt]    % it is a macro to save typing later
%\begin{center}     % 
%\includegraphics[#1]{#2} %
%\end{center}     %
%\caption{#3}     %
%\label{#4}     %
%\end{figure}     %
%}        %

%% Define the fields to be displayed by a \maketitle command
\author{Timothy Dee, Brent Barth}
%{\it Undergraduate, Department of Electrical and Computer Engineering, Iowa State University}
%\author{Brent Barth}
%\it Undergraduate, Department of Electrical and Computer Engineering, Iowa State University}
\title{GUI Car Simulation with Processor Depiction}

%%
%% Header now finished
%%

\begin{document}    % Critical
\twocolumn
\thispagestyle{empty}   % Inhibit the page number on this page
\maketitle      % Use the \author, \title and \date info

%% Next comes the abstract, notice the curly-braces surrounding the
%% text.

%%%%%%%%%%%%%%%%%%%%%
% PROJECT DESCRIPTION
%%%%%%%%%%%%%%%%%%%%%
%		CprE 458/558 Term Project Report Format (Sample)
%==========================================================================
%
%Here are some guidelines for the report. Page limits are mere suggestion,
%use number of pages as appropriate.
%
%There are three types of reports - survey, simulation, and implementation.
%
%Simulation/Implemenation Report Format (12-15 pages):
%
%       Project Summary  (1 page)
%       1. Introduction (2 pages)
%       2. Objectives and Scope (1 page)
%          Problem statement and Assumptions.
%       3. Solution Approach (3-4 pages)
%          3.1. Algorithm/Protocol (Discussion about the algo/protocol).
%          3.2 Illustrative Example
%       4. Simulation/Implementation (5 pages)
%          4.1. Simulation Model / Experimental Environment
%          4.2  Experiments and Analysis / Implementaion Details
%          4.3  Performance plots/ sample outputs / Sample screen output for GUI based simulator
%       5. Conclusions (3 pages)
%          5.1. Conclusion of the report; also, identify future work if relevant).
%          5.2  What did you learn by this project
%          5.3  Suggestion for such projects (feedback to the instructor)
%       References 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% report should convey some sort of learning, beyond what we learned in class

\abstract{This report describes a gui simulation created for Cpre 458, Real Time Systems. 
The simulation depicts a car driving and the state of the processor on the car. 
The car is shown to be reacting to obstacles in accordance to the tasks being submitting.
The tasks are represented visually in a panel which depicts the state of the processor.
This paper also discusses the specific implementation of the program.
This project design was inspired by the idea of autonomous driving, similar to Google Car.}

% Insert description from original project proposal
\section{Project Summary}
The goal of this project is to learn about the challenges associated with implementing a real-time system.
In accordance with this goal, it is necessary to think about real-life situation which can be modeled by simple means.
For purposes of this project, the situation must be scalable so a basic working version may be reached relatively swiftly while working toward the more complex desirable implementation.
For this reason, we choose to implement a simple version of an autonomous driving system.

The reason such a problem is a good candidate is due several factors.
First, the rules are well defined. Most people can easily understand what a car should do when it is on the road. This makes our depiction of the car easy to understand.
Second, such a problem is also scalable because an arbitrary number of objects which require some nature of response may be introduced.

The implementation of this system will need to visually represent a car driving on a road.
There will also need to be clear obstacles presented to the car.
Internally our program will need to use the ideas presented in Real-Time Systems to cause the car to react to the obstacles.
This internal state will also need to be visually depicted.

The idea for an autonomous driving simulation was inspired by Google Car.
Understanding what challenges need to be overcome overcome to make a system such as this possible is a very interesting prospect.
While this implementation project is very far from approaching the complexity level of Google Car, simplified versions of the challenges will remain.
Specifically these challenges involve reading data from the \'world\', deciding what actions to take based on that data, and preforming actions based on those decisions.

\section{Introduction}
%TODO

\section{Objectives and Scope}
The scope of this project is rather large.
The incorporation of two GUI components adds an amount of difficulty over and above simply a simulation of tasks going though a processor.
This extra complexity has a large value though as it puts the problem of implementing a real-time system into a real-life context.
Generating tasks based on the state of a GUI is much more visually interesting as well.

The goal will be able to implement everything in a modular way. If this can be done, then it will be easy to get a basic level of functionality while working toward a more complete implementation.
A specific example of this might be implementing scheduler interface. Classes which implement that interface could then preform all scheduling operations.
In this, a simple scheduler may be implemented swiftly and immediately while a more complex, desirable, scheduler can be implemented once the basic functionality is in place.

Basic functionality for this project will consist of achieving a functional level for all logical components.
A component has achieved a functional level if it can take input and provide the appropriate output.
A basic functional level for a scheduler then might be defined as the ability to take a list of tasks as parameters and produce a correct schedule.
A desirable functional level for the same scheduler might be an efficient algorithm for completing a correct schedule.
A desirable functional level for all schedulers might be the implementation of a very interesting scheduler, or a multi-processor scheduler.

The primary objective though is to learn of the challenges involved in the implementation of a real-time system.
Put in simple terms, how do you read information from a world which is generating data, analyze that data to decide how to react to it, and cause a reaction based on the decision.
The functions of reading and reacting to information are greatly simplified in our virtual world compared to the real world.
In the real world there is a vary large amount of noise data, while in our virtual world there are significantly fewer data sources and these data sources provide clean data.
Processing data derived from our virtual world is simplified by virtue of it having less noise when compared to real-world data.

Despite the simplified nature implicit in a virtual world, this project will accomplish its primary objective.
The problems faced when dealing with noisy data and specific actuator implementations are problems outside of the scope of this class which delves into the theory of real-time systems.
Given these conditions, the fact the the \'world\' is more simple allows the primary objective of this project to be accomplished more easily because this puts the emphasis of the implementation on the theory of a real-time system's operation.
Contrast this with a physical implementation where the main concern might be on data acquisition and actuator implementation.

%
% I removed a section here because I don't think it would be necessary or useful
%
\section{Simulation}
We seek to implement a system which demonstrates how the ideas from Real Time Systems may be applied to the autonomous driving problem.
For this, we choose to implement three distinct logical components.
First, we create an entity which keeps track of the state of the \'world\'. This entity will need to show this \'world\' based on the current state, and update the state. It will also need to derive information from the current state of the \'world\' which will enable the processing entity to know if it needs to cause the car to react to an obstacle.
Second, there must exist a sort of processing unit which maintains a list of tasks and performs the scheduling. This processing unit takes information from the first entity which maintains the state of the \'world\', using this information to modify on what element  processing will be done.
Third, there is a unit which takes in information regarding the state of the processing and shows it visually.

% block diagram of classes should probabally go here
\subsection{Simulation Model}
% Diagram of code
\begin{figure}[!hbt]
\begin{center}
\includegraphics[width=.4\textwidth,keepaspectratio]{code_layout.png}
\end{center}
\caption{Program Layout}
\label{FIG-DIAGRAM}
\end{figure}

Our program code follows a structure having objects with purpose similar to the logical components discussed in the preface of this section.
Figure \ref{FIG-DIAGRAM} illustrates this layout.
In this diagram, lines drawn between two entities represent a control relationship. The MainFrame, for example, controls the Simulate thread.
The Simulate thread, in turn, controls three additional threads. Each of these threads is preforming tasks consistent with the logical component they represent.
Arrows represent the flow of information.

In the diagram it can be seen that information flows from CarPanelState to SensorData to ProcessingState and finally to ProcessorPanelController.
Each of these objects or threads consume the information produced by the previous object or thread.
CarPanelState is updated by CarPanelController using logic which is consistent with the laws of physics.
This means if an object has a nonzero speed than it will move in accordance with that speed on each update of the panel.

SensorData is the mechanism by which information about the CarPanelState is communicated to  ProcessingState.
SensorData maintains a list of sensors which interpret the CarPanelState. These Sensors in turn make relevant information about the state accessible.
ProcessingState communicates information about the state of the processing to the ProcessorPanelController.
ProcessorPanelController in turn uses this to represent the information visually.

The diagram also depicts several threads.
Each of these thread will have jurisdiction over one of the logical components of the program. For example, CarPanelController will control how the CarPanel is updated and allow for the acquisition of information about the CarPanelState by other components.
Distributing the responsibility in this way makes the responsibilities of each portion of the program very clear.
This aids in simplicity of implementation and allows for easier debugging in the sense that when there is an error, the offending code is more easily located.
%TODO

% present code and explanations for design choices here
\subsection{Implementation Details}
Discussed here are the specific implementation details and program design choices.
The overall design philosophy utilized delegates as much processing as possible until it becomes trivial..
This means that components higher in the hierarchy should not need to have any knowledge of how the lower components preform their function.
A specific example of this is objects which represent a graphical element knowing how to draw themselves. In this example, the panel which contains the graphical element would ask it to draw itself, this is the delegation of work. 

% in each subsubsection, state:
% what the class is used to accomplish
% how the class fits into the overall program design
% important design decisions made in that class
% how this class interacts with other classes
\subsubsection{MainFrame}
% code used to set up the threads
\begin{lstlisting}[float=*,caption={Setup Threads},label={lst:threads},numbers=left]
// add the panels to this frame
CarPanel car_panel = new CarPanel(this.width, this.height);
ProcessorPanel processor_panel = new ProcessorPanel();
this.add(car_panel);
this.add(processor_panel);

// start any necessary threads
CarPanelController car_controller = new CarPanelController(car_panel);
ProcessorPanelController processor_controller = new ProcessorPanelController(processor_panel);
ProcessingController processing_controller = new ProcessingController(scheduling_algorithm, n_processors);

Thread car_controller_thread = new Thread(car_controller);
Thread processor_controller_thread = new Thread(processor_controller);
Thread processing_controller_thread = new Thread(processing_controller);
    
// start these threads, but they don't act autonamously. Simulate thread
// will use them to perform the simulation.
car_controller_thread.start();
processor_controller_thread.start();
processing_controller_thread.start();

// START SIMULATION THREAD
Simulate simulator = new Simulate(car_controller, processor_controller, processing_controller, width, height);
Thread simulator_thread = new Thread(simulator);
simulator_thread.start();
\end{lstlisting}

This class is used to establish properties of the main window for program simulation.
The goal of this class is to arrange the different visual components of the program and begin the simulation.
Here is where necessary design decisions about how the responsibilities of the program are delegated.
The choice was made to divide the responsibility among three different threads. An additional thread is used to coordinate activity among these other threads.
Listing \ref{lst:threads} shows the initialization of threads and how they are given to the fourth thread to be managed.

\subsubsection{Simulate}
% shows the update procedure in the simulate thread
\begin{lstlisting}[caption={Simulate Update Procedure},label={lst:simulate},numbers=left]
while (true) {
  try {
    // update every 3ms
    Thread.sleep(3);
  } catch (Exception e) {
    e.printStackTrace();
  }

  // provide the SensorData to the ProcessingController
  this.processing_controller.
    set_sensor_data(
      this.car_panel_controller.
      get_sensor_data());

  // provide the processing state to the processor panel
  this.processor_panel_controller.
    set_processing_state(this.processing_controller.
      get_state());
}
\end{lstlisting}


This thread has two goals. 
It's primary purpose is to coordinate activity among the other threads which manage the visual components and the processing.
This thread's secondary goal is to set up all of the obstacles and periodic tasks used in the simulation. 
Periodic tasks, once submitted to the ProcessingController, will be re-injected into the task queue every time their period has expired.
The only method by which obstacles may be inserted at this time is by creating them and giving them to the CarPanelController.
The original plan for implementing the obstacle generation was to create a thread which would insert obstacles occasionally.
This is something we were not able to implement due to time constraints.

Listing \ref{lst:simulate} describes the update procedure.
The SensorData construct is taken from the CarPanelController and given to the ProcessingController thread to be utilized by the currently running periodic and aperiodic tasks.
The processing state is taken from the ProcessingController and given to the ProcessorPanelController to be drawn.
This update procedure happens at a frequency greater than the update procedures in the other threads.
The purpose of this increased frequency is to attempt to ensure the data the ProcessingController and ProcessingPanelController are using are not stale.
This is what is meant by \"coordinate activity among the other threads\".

\subsubsection{CarPanelController}
\begin{lstlisting}[caption={Panel Update Procedure},label={lst:carpanelcontroller},numbers=left]
private void update_panel() {
  // update the targets if necessary
  update_target_state();

  // call methods to perform various specific updates
  move_car();
  move_obstacles();
  move_other_cars();
  move_signs();
  move_road();

  // cause the panel and its children to repaint
  this.car_panel.repaint();
  this.car_panel.revalidate();
}
\end{lstlisting}

Listing \ref{lst:carpanelcontroller} depicts the method called within CarPanelController as the update procedure.
That is, this function runs approximately every 10 milliseconds.
This class maintains the real state of the objects drawn to the panel depicting the car.
This class also maintains another state which describes the intended position or goal for the objects.
We call this state the target state.
Most methods in the update procedure update the target state in some way.

The first method, update\_target\_state, performs any updates to the target state which are not related to any objects on screen.
The next set of methods update the target state based on the speed and current position of the objects on screen.
The general rule is if the target state is different from the real state, then we move the real state one closer to the target state.
In this way, we maintain incremental movement of the objects on screen.
This ensures the objects move smoothly.

\subsubsection{ProcessingController}
\begin{lstlisting}[caption={Processing Controller Update Procedure},label={lst:ProcessingController},numbers=left]
while (true) {
  try {
    // update every 10 ms (100 fps)
    Thread.sleep(10);
  } catch (Exception e) {
    e.printStackTrace();
  }

  // ask the state to update itself
  processing_state.update(1L);
}
\end{lstlisting}

Listing \ref{lst:ProcessingController} depicts the update process for processing controller
%TODO

\subsubsection{ProcessorPanelController}
\begin{lstlisting}[caption={Processing Panel Update Procedure},label={lst:ProcessingPanelController},numbers=left]
while (true) {
  try {
    // update every 10 ms (100 fps)
    Thread.sleep(10);
  } catch (Exception e) {
    e.printStackTrace();
  }

  set_processing_state(this.processor_panel.getState());
  
  // cause the processor panel to be repainted
  processor_panel.repaint();
  processor_panel.revalidate();
}
\end{lstlisting}

\ref{lst:ProcessingPanelController}
%TODO

\subsubsection{CarPanel}
\begin{lstlisting}[caption={Ask Signs to Draw Themselves},label={lst:CarPanel},numbers=left]
for (Sign c : state.signs) {
  c.draw(g);
}
\end{lstlisting}

\ref{lst:CarPanel} illustrates the design philosophy. 
This shows how components are asked to draw themselves.
%TODO

\subsubsection{CarPanelState}
\begin{lstlisting}[caption={Car Panel State maintains all objects drawn on the screen},label={lst:CarPanelState},numbers=left]
public MainCar main_car;
public Road road;

public ArrayList<Cone> obstacles;
public ArrayList<Car> other_cars;
public ArrayList<Sign> signs;
\end{lstlisting}

\ref{lst:CarPanelState}
%TODO

\subsubsection{Character}
\begin{lstlisting}[caption={Sample Implementation of a Character},label={lst:character},numbers=left]
public void draw(Graphics g) {
  // draw the body of the car
  g.setColor(this.color);
  g.fillRect(this.x_pos, this.y_pos, this.width, this.height);

  if (Facing.RIGHT == this.facing) {
    // draw the windshield
    g.setColor(Color.black);
    g.fillRect(this.x_pos + this.width / 2 + this.width / 16, this.y_pos + this.height / 10, this.width / 3,
        this.height * 4 / 5);
  } else {
    // draw the windshield
    g.setColor(Color.black);
    g.fillRect(this.x_pos + this.width / 16, this.y_pos + this.height / 10, this.width / 3,
        this.height * 4 / 5);
  }
}
\end{lstlisting}

\ref{lst:character}
%TODO

\subsubsection{SensorData}
\begin{lstlisting}[caption={Sensor Data maintains a number of sensors},label={lst:SensorData},numbers=left]
public StopSignSensor stop_sign_sensor;
public SpeedSignSensor speed_sign_sensor;
public OtherCarSensor other_car_sensor;
public ConeSensor cone_sensor;
\end{lstlisting}

\ref{lst:SensorData}
%TODO

\subsubsection{Sensor}
\begin{lstlisting}[float=*,caption={Implementation of Sensor},label={lst:sensor},numbers=left]
public class StopSignSensor extends Sensor {
  public ArrayList<Sign> signs;
  public ArrayList<Double> distances;

  public StopSignSensor(CarPanelState state) {
    super(state);
  }

  @Override
  protected void compute() {
    this.signs = new ArrayList<Sign>();
    this.distances = new ArrayList<Double>();

    for (Sign sign : this.car_panel_state.signs) {
      if (sign.type == SignType.STOP && is_within_range(this.car_panel_state.main_car, sign)) {
        // if within range of sensor
        signs.add(sign);

        // add in parallel the distance to the sign
        distances.add(compute_distance(this.car_panel_state.main_car, sign));
      }
    }
  }
}
\end{lstlisting}

\ref{lst:sensor}
%TODO

\subsubsection{ProcessingState}
\begin{lstlisting}[float=*,caption={Scheduler call and task queue manipulation},label={lst:ProcessingState},numbers=left]
private void update_processors(long time) {
  // preform updates in an incremental fashion
  for (int i = 0; i < time; i++) {
    // if a task has completed, run the scheduler at the point it
    // completes.
    // remember the only tasks who's computation time is decreasing are
    // the ones in the processors.
    for (Processor p : processors) {
      // first, decrement the computation time of the thing in this
      // processor
      p.task.computation_time_remaining--;

      if (p.task.computation_time_remaining <= 0) {
        // periodic tasks need to be added back
        if (p.task.nature == Task.Nature.PERIODIC) {
          // add the same task back in if it is periodic
          this.scheduler_task_queue.add(new Task(p.task.computation_time_origional, p.task.period,
              p.task.deadline, p.task.nature, p.task.action, p.task.processing_controller,
              p.task.car_panel_controller, p.task.set_point));
        }

        // preform the complete action of the task when it is
        // finished
        p.task.preform_action();

        // if the task has finished, get the next thing out of the
        // queue
        // set the current processor task to the smallest thing in
        // the queue
        if (p.task_queue.isEmpty() == false) {
          // get the next task in the queuue
          p.task = p.task_queue.get(0);

          // remove this task from the queue
          p.task_queue.remove(0);
        } else {
          // insert a dummy task
          p.task = new Task(1, 0, 0, Nature.APERIODIC, Action.NONE, null, null, 0);
        }
      }
    }
  }
}
\end{lstlisting}

\ref{lst:ProcessingState}
%TODO

\subsubsection{Task}
\begin{lstlisting}[caption={Tasks know how to preform their actions},label={lst:task},numbers=left]
// says what action should be conducted upon task completion
public enum Action {
  NONE, SET_CAR_SPEED, MOVE_UP_CAR, MOVE_DOWN_CAR, READ_CONE_SENSOR, READ_OTHER_CAR_SENSOR, READ_SPEED_SIGN_SENSOR, READ_STOP_SIGN_SENSOR;
}

public void preform_action();
\end{lstlisting}

\ref{lst:task}
Based on their action, tasks will choose to do different things in the preform\_action method.
Whenever a task reads a sensor, it will start any appropriate aperiodic tasks.
%TODO

\subsubsection{Scheduler}
\begin{lstlisting}[caption={The scheduler uses a scheduling algorithm to choose the order of tasks},label={lst:scheduler},numbers=left]
/**
 * returns the task set in scheduled order. null if not schedulable.
 */
public ArrayList<List<Task>> schedule(List<Task> tasks, int n_processors) {
  ArrayList<Task> array_list_tasks = new ArrayList<Task>(tasks);

  return this.scheduling_algorithm.schedule(
    array_list_tasks, n_processors);
}
\end{lstlisting}

\ref{lst:scheduler}
%TODO

\subsubsection{SchedulingAlgorithm}
\begin{lstlisting}[caption={Scheduling Algorithm interface},label={lst:SchedulingAlgorithm},numbers=left]
public interface SchedulingAlgorithm {
  /**
   * returns a schedule of all tasks for n processors. Each processor has a
   * different list in the task set.
   * 
   * @param tasks
   * @return
   */
  public List<List<Task>> schedule(List<Task> tasks, int n_processors);
}
\end{lstlisting}

\ref{lst:SchedulingAlgorithm}
any number of these might be implemented
%TODO

\subsubsection{Processor}
\begin{lstlisting}[caption={},label={lst:processor},numbers=left]
public Task task;
public List<Task> task_queue;
\end{lstlisting}

\ref{lst:processor}
%TODO

\subsubsection{ProcessorPanel}
\begin{lstlisting}[caption={},label={lst:ProcessorPanel},numbers=left]
protected void paintComponent(Graphics g) {
  super.paintComponent(g);

  drawSchedulerQueueTasks(g);
  drawTaskTables(g);
  drawLabels(g);
  draw_signs(g);
}
\end{lstlisting}

\ref{lst:ProcessorPanel}
%TODO

\subsection{Implemented Scheduling Algorithms}
\subsubsection{EDF}
%TODO

\subsubsection{RMS}
%TODO

\subsubsection{TODO}
%TODO

% put a picture of the GUI screen here
\subsection{Outputs}
%TODO

\section{Conclusion}
% what was good, what was bad
% what went well, what did not go well
\subsection{Synopsis}
%TODO

\subsection{Learning}
The primary objective of this project was to learn about the challenges involved in implementing a real time system.
It seems this goal was accomplished. We feel that we have a much more complete understanding of the ideas in this course.
It is one thing to speak about theory. It is an entirely different thing to implement the theory.
There was also learning concerning the specific problems involved in implementing a GUI simulation.
Something which is seemingly trivial, such as a car driving on a road, can present interesting problems making it exceptionally challenging.

Learning in the context of real-time systems was benefited by
creating something and seeing what issues present themselves in practice allows a person to understand the motivation behind doing things in a particular way.
For instance, a person might ask, \"Why not just complete the tasks in the order they arrive?\". Before doing this project, I would have probably answered in terms of the theory of real-time system.
Such an answer might involve why we must maintain priorities for tasks so these tasks meet their deadline.
After doing this project, I can now answer in the context of a real-life example. I can say
\it why \normalfont
tasks must meet their deadlines and give illustrative examples of what might happen should a task miss it's deadline.

%TODO talk more about real-time systems learning

There was also significant knowledge acquisition in our ability to create GUI simulation simulations.
There are many interesting problems related to attempting to visually realize data.
One of the first challenges we faced in creating our solution was designing the organizational structure in a modular way which would allow for the addition of new components.
To overcome this challenge we decided to delegate work as far as possible.
This way any additional objects, such as a new obstacle or sign, would not have to worry about any of the structure above them.
In some sense the goal was to maintain a separation of responsibility. In this paradigm delegating work as far as possible was the algorithm used to accomplish that.

Another significant issue in creating a GUI simulation is fluid motion.
To enable objects to move fluidly on the screen is not trivial; doing this requires the state of the objects to be updated in a very specific way.
CarPanelController initiates an update of CarPanel every 10 milliseconds. This equates to roughly 100 frames per second. Of course it will be less because the frequency of updates in reality is $fps = \frac{1000 ms}{1 s} \times \frac{1 frame}{10ms + n}$ where $n$ is the time in milliseconds taken by the code that describes what is to be drawn on the panel.
If the screen is not updated frequently enough, then the movement will appear choppy.
This is why it is necessary to update so many times. Likely the screen is only updated around 60 times per second due to the refresh rate of most monitors, having our program preform the update around 100 times per second allows us to always meet this number of frames.

Another component of the fluid moment problem, apart from when to draw to the screen, is deciding what to draw to the screen.
We found that if you try to move objects more than one or two pixels at a time then the objects will appear choppy.
This gave rise to a really neat way of updating the CarPanelState from which the objects in the CarPanel are drawn.
CarPanelController maintains two states. 
One state is the target state which is updated by external sources, namely tasks, when these sources want to tell the car to move somewhere on the screen.
The other state is the real state that is given to CarPanel to be drawn.
Every time CarPanelController updates, the real state is moved one step closer to the target state.
For instance, 
if the y position of the main car in the real state is greater than the y position of the main car in the target state, 
than the y position of the car in the real state will be decremented before being given to the CarPanel to be drawn.
In this way, objects are only moved one or two pixels at a time, assuming the refresh rate of the monitor running this program is above $50hz$.

% what was good, what was bad
\subsection{Suggestions}
It is good that the project is open-ended.
This gave us an opportunity to learn in a way which is interesting to us.
I felt a lot more motivated to do this project then I would have if it was a normal well-defined, highly-structured project.
It is much nicer to learn this way in my opinion.

I think it would be better if the project began earlier in the semester.
Having the start of the project be less than three weeks before dead week put a huge strain on time at this point in the semester.
I understand that it doesn't make sense to start the project before a significant amount of material has been covered.
Potentially making the report requirement slightly less substantial would help.

% listing example
%\begin{lstlisting}[float=*,caption={Dynamic Frequency Scaling Mode II},label={lst:DFS_2},numbers=left]
%hi
%\end{lstlisting}

%% This bit generates the references.  This part starts to get
%% slightly tricky.
\bibliographystyle{unsrt} % Order by citation
\bibliography{report}

\end{document}