package compute;

import java.util.ArrayList;

import scheduler.Processor;
import scheduler.Scheduler;
import scheduler.SchedulingAlgorithm;
import scheduler.Task;

/**
 * captures all information about the processing state.
 * 
 * This includes:
 * 
 * 1) scheduler task queue 2) scheduler 4) processors task queues 5) processors
 * 
 * @author element
 *
 */
public class ProcessingState {
	private ArrayList<Task> scheduler_task_queue;
	private Scheduler scheduler;

	private ArrayList<Task> processor_task_queue;
	private ArrayList<Processor> processors;

	public ProcessingState(SchedulingAlgorithm scheduling_algorithm) {
		this.scheduler_task_queue = new ArrayList<Task>();
		this.scheduler = new Scheduler(scheduling_algorithm);

		this.processor_task_queue = new ArrayList<Task>();

		// set up processors
		this.processors = new ArrayList<Processor>();
		processors.add(new Processor());
	}

	/**
	 * updates task data with the amount of time that has passed. preforms all
	 * necessary actions based on the time.
	 * 
	 * @param time
	 */
	public void update(long time) {
		// preform updates in an incremental fashion
		for (int i = 0; i < time; i++) {
			// TODO increase all time dependtant things by 1

			// if a task has completed, run the scheduler at the point it
			// completes.
			// remember the only tasks who's computation time is decreasing are
			// the ones in the processors.
			for (Processor p : processors) {
				// first, decrement the computation time of the thing in this
				// processor
				p.task.computation_time_remaining--;

				if (p.task.compuatation_time_remaining <= 0) {
					// if the task has finished, get the next thing out of the
					// queue
					// set the current processor task to the smallest thing in
					// the queue
					if (processor_task_queue.isEmpty() == false) {
						p.task = processor_task_queue.get(0);
					}
				}
			}
		}
	}
}
